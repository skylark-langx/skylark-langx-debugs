{"version":3,"sources":["Stacktrace.js"],"names":["define","debug","StackTrace","options","ex","guess","e","p","implementation","result","run","guessAnonymousFunctions","prototype","mode","this","createException","other","arguments","callee","undef","stack","message","window","opera","stacktrace","indexOf","split","length","instrumentFunction","context","functionName","callback","original","call","slice","_instrumented","apply","deinstrumentFunction","constructor","Function","chrome","replace","pop","firefox","opera11","lineRE","lines","i","len","match","exec","location","fnName","push","opera10b","opera10a","opera9","ANON","curr","fn","args","fnRE","test","toString","RegExp","$1","Array","stringifyArguments","caller","arg","undefined","Object","String","Number","join","sourceCache","ajax","url","req","createXMLHTTPObject","open","send","responseText","xmlhttp","XMLHttpFactories","XMLHttpRequest","ActiveXObject","isSameDomain","hostname","getSource","frame","ref","m","file","lineno","charno","guessAnonymousFunction","lineNo","charNo","ret","findFunctionName","source","line","commentPos","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","code","maxLines","Math","min","substr"],"mappings":"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","file":"../Stacktrace.js","sourcesContent":["define([\"./debug\"],function(debug) {\n\n    // The module borrowed the following programï¼š \n    //   Domain Public by Eric Wendelin http://eriwen.com/ (2008)\n    //                  Luke Smith http://lucassmith.name/ (2008)\n    //                  Loic Dachary <loic@dachary.org> (2008)\n    //                  Johan Euphrosine <proppy@aminche.com> (2008)\n    //                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\n    //                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\n\n    /**\n     * Main function giving a function stack trace with a forced or passed in Error\n     *\n     * @cfg {Error} e The error to create a stacktrace from (optional)\n     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\n     * @return {Array} of Strings with functions, lines, files, and arguments where possible\n     */\n    function StackTrace(options) {\n        options = options || {guess: true};\n        var ex = options.e || null, guess = !!options.guess;\n        var p = new StackTrace.implementation(), result = p.run(ex);\n        return (guess) ? p.guessAnonymousFunctions(result) : result;\n    }\n\n    StackTrace.implementation = function() {\n    };\n\n    StackTrace.implementation.prototype = {\n        /**\n         * @param {Error} ex The error to create a stacktrace from (optional)\n         * @param {String} mode Forced mode (optional, mostly for unit tests)\n         */\n        run: function(ex, mode) {\n            ex = ex || this.createException();\n            // examine exception properties w/o debugger\n            //for (var prop in ex) {alert(\"Ex['\" + prop + \"']=\" + ex[prop]);}\n            mode = mode || this.mode(ex);\n            if (mode === 'other') {\n                return this.other(arguments.callee);\n            } else {\n                return this[mode](ex);\n            }\n        },\n\n        createException: function() {\n            try {\n                this.undef();\n            } catch (e) {\n                return e;\n            }\n        },\n\n        /**\n         * Mode could differ for different exception, e.g.\n         * exceptions in Chrome may or may not have arguments or stack.\n         *\n         * @return {String} mode of operation for the exception\n         */\n        mode: function(e) {\n            if (e['arguments'] && e.stack) {\n                return 'chrome';\n            } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\n                // e.message.indexOf(\"Backtrace:\") > -1 -> opera\n                // !e.stacktrace -> opera\n                if (!e.stacktrace) {\n                    return 'opera9'; // use e.message\n                }\n                // 'opera#sourceloc' in e -> opera9, opera10a\n                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n                    return 'opera9'; // use e.message\n                }\n                // e.stacktrace && !e.stack -> opera10a\n                if (!e.stack) {\n                    return 'opera10a'; // use e.stacktrace\n                }\n                // e.stacktrace && e.stack -> opera10b\n                if (e.stacktrace.indexOf(\"called from line\") < 0) {\n                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\n                }\n                // e.stacktrace && e.stack -> opera11\n                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\n            } else if (e.stack) {\n                return 'firefox';\n            }\n            return 'other';\n        },\n\n        /**\n         * Given a context, function name, and callback function, overwrite it so that it calls\n         * StackTrace() first with a callback and then runs the rest of the body.\n         *\n         * @param {Object} context of execution (e.g. window)\n         * @param {String} functionName to instrument\n         * @param {Function} function to call with a stack trace on invocation\n         */\n        instrumentFunction: function(context, functionName, callback) {\n            context = context || window;\n            var original = context[functionName];\n            context[functionName] = function instrumented() {\n                callback.call(this, StackTrace().slice(4));\n                return context[functionName]._instrumented.apply(this, arguments);\n            };\n            context[functionName]._instrumented = original;\n        },\n\n        /**\n         * Given a context and function name of a function that has been\n         * instrumented, revert the function to it's original (non-instrumented)\n         * state.\n         *\n         * @param {Object} context of execution (e.g. window)\n         * @param {String} functionName to de-instrument\n         */\n        deinstrumentFunction: function(context, functionName) {\n            if (context[functionName].constructor === Function &&\n                    context[functionName]._instrumented &&\n                    context[functionName]._instrumented.constructor === Function) {\n                context[functionName] = context[functionName]._instrumented;\n            }\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Chrome's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        chrome: function(e) {\n            var stack = (e.stack + '\\n').replace(/^\\S[^\\(]+?[\\n$]/gm, '').\n              replace(/^\\s+(at eval )?at\\s+/gm, '').\n              replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}()@$1$2').\n              replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}()@$1').split('\\n');\n            stack.pop();\n            return stack;\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Firefox's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        firefox: function(e) {\n            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^\\(/gm, '{anonymous}(').split('\\n');\n        },\n\n        opera11: function(e) {\n            // \"Error thrown at line 42, column 12 in <anonymous function>() in file://localhost/G:/js/stacktrace.js:\\n\"\n            // \"Error thrown at line 42, column 12 in <anonymous function: createException>() in file://localhost/G:/js/stacktrace.js:\\n\"\n            // \"called from line 7, column 4 in bar(n) in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\n            // \"called from line 15, column 3 in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\n            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var location = match[4] + ':' + match[1] + ':' + match[2];\n                    var fnName = match[3] || \"global code\";\n                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\n                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        opera10b: function(e) {\n            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\n            // \"StackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\n            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\n            var lineRE = /^(.*)@(.+):(\\d+)$/;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i++) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var fnName = match[1]? (match[1] + '()') : \"global code\";\n                    result.push(fnName + '@' + match[2] + ':' + match[3]);\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        opera10a: function(e) {\n            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var fnName = match[3] || ANON;\n                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 7.x-9.2x only!\n        opera9: function(e) {\n            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n'), result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        // Safari, IE, and others\n        other: function(curr) {\n            var ANON = '{anonymous}', fnRE = /function\\s*([\\w\\-$]+)?\\s*\\(/i, stack = [], fn, args, maxStackSize = 10;\n            while (curr && curr['arguments'] && stack.length < maxStackSize) {\n                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\n                args = Array.prototype.slice.call(curr['arguments'] || []);\n                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\n                curr = curr.caller;\n            }\n            return stack;\n        },\n\n        /**\n         * Given arguments array as a String, subsituting type names for non-string types.\n         *\n         * @param {Arguments} object\n         * @return {Array} of Strings with stringified arguments\n         */\n        stringifyArguments: function(args) {\n            var result = [];\n            var slice = Array.prototype.slice;\n            for (var i = 0; i < args.length; ++i) {\n                var arg = args[i];\n                if (arg === undefined) {\n                    result[i] = 'undefined';\n                } else if (arg === null) {\n                    result[i] = 'null';\n                } else if (arg.constructor) {\n                    if (arg.constructor === Array) {\n                        if (arg.length < 3) {\n                            result[i] = '[' + this.stringifyArguments(arg) + ']';\n                        } else {\n                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\n                        }\n                    } else if (arg.constructor === Object) {\n                        result[i] = '#object';\n                    } else if (arg.constructor === Function) {\n                        result[i] = '#function';\n                    } else if (arg.constructor === String) {\n                        result[i] = '\"' + arg + '\"';\n                    } else if (arg.constructor === Number) {\n                        result[i] = arg;\n                    }\n                }\n            }\n            return result.join(',');\n        },\n\n        sourceCache: {},\n\n        /**\n         * @return the text from a given URL\n         */\n        ajax: function(url) {\n            var req = this.createXMLHTTPObject();\n            if (req) {\n                try {\n                    req.open('GET', url, false);\n                    //req.overrideMimeType('text/plain');\n                    //req.overrideMimeType('text/javascript');\n                    req.send(null);\n                    //return req.status == 200 ? req.responseText : '';\n                    return req.responseText;\n                } catch (e) {\n                }\n            }\n            return '';\n        },\n\n        /**\n         * Try XHR methods in order and store XHR factory.\n         *\n         * @return <Function> XHR function or equivalent\n         */\n        createXMLHTTPObject: function() {\n            var xmlhttp, XMLHttpFactories = [\n                function() {\n                    return new XMLHttpRequest();\n                }, function() {\n                    return new ActiveXObject('Msxml2.XMLHTTP');\n                }, function() {\n                    return new ActiveXObject('Msxml3.XMLHTTP');\n                }, function() {\n                    return new ActiveXObject('Microsoft.XMLHTTP');\n                }\n            ];\n            for (var i = 0; i < XMLHttpFactories.length; i++) {\n                try {\n                    xmlhttp = XMLHttpFactories[i]();\n                    // Use memoization to cache the factory\n                    this.createXMLHTTPObject = XMLHttpFactories[i];\n                    return xmlhttp;\n                } catch (e) {\n                }\n            }\n        },\n\n        /**\n         * Given a URL, check if it is in the same domain (so we can get the source\n         * via Ajax).\n         *\n         * @param url <String> source url\n         * @return False if we need a cross-domain request\n         */\n        isSameDomain: function(url) {\n            return url.indexOf(location.hostname) !== -1;\n        },\n\n        /**\n         * Get source code from given URL if in the same domain.\n         *\n         * @param url <String> JS source URL\n         * @return <Array> Array of source code lines\n         */\n        getSource: function(url) {\n            // TODO reuse source from script tags?\n            if (!(url in this.sourceCache)) {\n                this.sourceCache[url] = this.ajax(url).split('\\n');\n            }\n            return this.sourceCache[url];\n        },\n\n        guessAnonymousFunctions: function(stack) {\n            for (var i = 0; i < stack.length; ++i) {\n                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\n                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\n                    frame = stack[i], ref = reStack.exec(frame);\n\n                if (ref) {\n                    var m = reRef.exec(ref[1]);\n                    if (m) { // If falsey, we did not get any file/line information\n                        var file = m[1], lineno = m[2], charno = m[3] || 0;\n                        if (file && this.isSameDomain(file) && lineno) {\n                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\n                            stack[i] = frame.replace('{anonymous}', functionName);\n                        }\n                    }\n                }\n            }\n            return stack;\n        },\n\n        guessAnonymousFunction: function(url, lineNo, charNo) {\n            var ret;\n            try {\n                ret = this.findFunctionName(this.getSource(url), lineNo);\n            } catch (e) {\n                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\n            }\n            return ret;\n        },\n\n        findFunctionName: function(source, lineNo) {\n            // FIXME findFunctionName fails for compressed source\n            // (more than one function on the same line)\n            // TODO use captured args\n            // function {name}({args}) m[1]=name m[2]=args\n            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n            // {name} = function ({args}) TODO args capture\n            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\n            var reFunctionExpression = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function\\b/;\n            // {name} = eval()\n            var reFunctionEvaluation = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n            // Walk backwards in the source lines until we find\n            // the line which matches one of the patterns above\n            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\n            for (var i = 0; i < maxLines; ++i) {\n                // lineNo is 1-based, source[] is 0-based\n                line = source[lineNo - i - 1];\n                commentPos = line.indexOf('//');\n                if (commentPos >= 0) {\n                    line = line.substr(0, commentPos);\n                }\n                // TODO check other types of comments? Commented code may lead to false positive\n                if (line) {\n                    code = line + code;\n                    m = reFunctionExpression.exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                    m = reFunctionDeclaration.exec(code);\n                    if (m && m[1]) {\n                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\n                        return m[1];\n                    }\n                    m = reFunctionEvaluation.exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n            return '(?)';\n        }\n    };\n\n    return debug.StackTrace = StackTrace;\n});\n"]}