{"version":3,"sources":["stack-trace.js"],"names":["define","debugs","StackTrace","options","ex","guess","e","p","implementation","result","run","guessAnonymousFunctions","prototype","mode","this","createException","other","arguments","callee","undef","stack","message","window","opera","stacktrace","indexOf","split","length","instrumentFunction","context","functionName","callback","original","call","slice","_instrumented","apply","deinstrumentFunction","constructor","Function","chrome","replace","pop","firefox","opera11","lineRE","lines","i","len","match","exec","location","fnName","push","opera10b","opera10a","opera9","ANON","curr","fn","args","fnRE","test","toString","RegExp","$1","Array","stringifyArguments","caller","arg","undefined","Object","String","Number","join","sourceCache","ajax","url","req","createXMLHTTPObject","open","send","responseText","xmlhttp","XMLHttpFactories","XMLHttpRequest","ActiveXObject","isSameDomain","hostname","getSource","frame","ref","m","file","lineno","charno","guessAnonymousFunction","lineNo","charNo","ret","findFunctionName","source","line","commentPos","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","code","maxLines","Math","min","substr"],"mappings":";;;;;;;AAAAA,QAAQ,YAAY,SAASC,GAiBzB,SAASC,EAAWC,GAEhB,IAAIC,GADJD,EAAUA,IAAYE,OAAO,IACZC,GAAK,KAAMD,IAAUF,EAAQE,MAC1CE,EAAI,IAAIL,EAAWM,eAAkBC,EAASF,EAAEG,IAAIN,GACxD,OAAO,EAAUG,EAAEI,wBAAwBF,GAAUA,EA+YzD,OA5YAP,EAAWM,eAAiB,aAG5BN,EAAWM,eAAeI,WAKtBF,IAAK,SAASN,EAAIS,GAKd,OAJAT,EAAKA,GAAMU,KAAKC,kBAIH,WADbF,EAAOA,GAAQC,KAAKD,KAAKT,IAEdU,KAAKE,MAAMC,UAAUC,QAErBJ,KAAKD,GAAMT,IAI1BW,gBAAiB,WACb,IACID,KAAKK,QACP,MAAOb,GACL,OAAOA,IAUfO,KAAM,SAASP,GACX,OAAIA,EAAa,WAAKA,EAAEc,MACb,SACqB,iBAAdd,EAAEe,SAA0C,oBAAXC,QAA0BA,OAAOC,MAG3EjB,EAAEkB,WAIHlB,EAAEe,QAAQI,QAAQ,OAAS,GAAKnB,EAAEe,QAAQK,MAAM,MAAMC,OAASrB,EAAEkB,WAAWE,MAAM,MAAMC,OACjF,SAGNrB,EAAEc,MAIHd,EAAEkB,WAAWC,QAAQ,oBAAsB,EACpC,WAGJ,UAPI,WARA,SAgBJnB,EAAEc,MACF,UAEJ,SAWXQ,mBAAoB,SAASC,EAASC,EAAcC,GAEhD,IAAIC,GADJH,EAAUA,GAAWP,QACEQ,GACvBD,EAAQC,GAAgB,WAEpB,OADAC,EAASE,KAAKnB,KAAMZ,IAAagC,MAAM,IAChCL,EAAQC,GAAcK,cAAcC,MAAMtB,KAAMG,YAE3DY,EAAQC,GAAcK,cAAgBH,GAW1CK,qBAAsB,SAASR,EAASC,GAChCD,EAAQC,GAAcQ,cAAgBC,UAClCV,EAAQC,GAAcK,eACtBN,EAAQC,GAAcK,cAAcG,cAAgBC,WACxDV,EAAQC,GAAgBD,EAAQC,GAAcK,gBAUtDK,OAAQ,SAASlC,GACb,IAAIc,GAASd,EAAEc,MAAQ,MAAMqB,QAAQ,oBAAqB,IACxDA,QAAQ,yBAA0B,IAClCA,QAAQ,sBAAuB,sBAC/BA,QAAQ,uCAAwC,oBAAoBf,MAAM,MAE5E,OADAN,EAAMsB,MACCtB,GASXuB,QAAS,SAASrC,GACd,OAAOA,EAAEc,MAAMqB,QAAQ,kBAAmB,IAAIA,QAAQ,QAAS,gBAAgBf,MAAM,OAGzFkB,QAAS,SAAStC,GAQd,IAHA,IAA0BuC,EAAS,sDAC/BC,EAAQxC,EAAEkB,WAAWE,MAAM,MAAOjB,KAE7BsC,EAAI,EAAGC,EAAMF,EAAMnB,OAAQoB,EAAIC,EAAKD,GAAK,EAAG,CACjD,IAAIE,EAAQJ,EAAOK,KAAKJ,EAAMC,IAC9B,GAAIE,EAAO,CACP,IAAIE,EAAWF,EAAM,GAAK,IAAMA,EAAM,GAAK,IAAMA,EAAM,GACnDG,EAASH,EAAM,IAAM,cACzBG,EAASA,EAAOX,QAAQ,8BAA+B,MAAMA,QAAQ,uBARlE,eASHhC,EAAO4C,KAAKD,EAAS,IAAMD,EAAW,OAASL,EAAMC,EAAI,GAAGN,QAAQ,OAAQ,MAIpF,OAAOhC,GAGX6C,SAAU,SAAShD,GAOf,IAHA,IAAIuC,EAAS,oBACTC,EAAQxC,EAAEkB,WAAWE,MAAM,MAAOjB,KAE7BsC,EAAI,EAAGC,EAAMF,EAAMnB,OAAQoB,EAAIC,EAAKD,IAAK,CAC9C,IAAIE,EAAQJ,EAAOK,KAAKJ,EAAMC,IAC9B,GAAIE,EAAO,CACP,IAAIG,EAASH,EAAM,GAAKA,EAAM,GAAK,KAAQ,cAC3CxC,EAAO4C,KAAKD,EAAS,IAAMH,EAAM,GAAK,IAAMA,EAAM,KAI1D,OAAOxC,GASX8C,SAAU,SAASjD,GAMf,IAHA,IAA0BuC,EAAS,6DAC/BC,EAAQxC,EAAEkB,WAAWE,MAAM,MAAOjB,KAE7BsC,EAAI,EAAGC,EAAMF,EAAMnB,OAAQoB,EAAIC,EAAKD,GAAK,EAAG,CACjD,IAAIE,EAAQJ,EAAOK,KAAKJ,EAAMC,IAC9B,GAAIE,EAAO,CACP,IAAIG,EAASH,EAAM,IANhB,cAOHxC,EAAO4C,KAAKD,EAAS,MAAQH,EAAM,GAAK,IAAMA,EAAM,GAAK,OAASH,EAAMC,EAAI,GAAGN,QAAQ,OAAQ,MAIvG,OAAOhC,GAIX+C,OAAQ,SAASlD,GAMb,IAHA,IAA0BuC,EAAS,oCAC/BC,EAAQxC,EAAEe,QAAQK,MAAM,MAAOjB,KAE1BsC,EAAI,EAAGC,EAAMF,EAAMnB,OAAQoB,EAAIC,EAAKD,GAAK,EAAG,CACjD,IAAIE,EAAQJ,EAAOK,KAAKJ,EAAMC,IAC1BE,GACAxC,EAAO4C,KAAKI,iBAAeR,EAAM,GAAK,IAAMA,EAAM,GAAK,OAASH,EAAMC,EAAI,GAAGN,QAAQ,OAAQ,KAIrG,OAAOhC,GAIXO,MAAO,SAAS0C,GAEZ,IADA,IAA6EC,EAAIC,EAAvDC,EAAO,+BAAgCzC,KAC1DsC,GAAQA,EAAgB,WAAKtC,EAAMO,OAD4D,IAElGgC,EAAKE,EAAKC,KAAKJ,EAAKK,aAAcC,OAAOC,IAFlC,cAGPL,EAAOM,MAAMtD,UAAUsB,MAAMD,KAAKyB,EAAgB,eAClDtC,EAAMA,EAAMO,QAAUgC,EAAK,IAAM7C,KAAKqD,mBAAmBP,GAAQ,IACjEF,EAAOA,EAAKU,OAEhB,OAAOhD,GASX+C,mBAAoB,SAASP,GAGzB,IAFA,IAAInD,KACAyB,EAAQgC,MAAMtD,UAAUsB,MACnBa,EAAI,EAAGA,EAAIa,EAAKjC,SAAUoB,EAAG,CAClC,IAAIsB,EAAMT,EAAKb,QACHuB,IAARD,EACA5D,EAAOsC,GAAK,YACG,OAARsB,EACP5D,EAAOsC,GAAK,OACLsB,EAAI/B,cACP+B,EAAI/B,cAAgB4B,MAChBG,EAAI1C,OAAS,EACblB,EAAOsC,GAAK,IAAMjC,KAAKqD,mBAAmBE,GAAO,IAEjD5D,EAAOsC,GAAK,IAAMjC,KAAKqD,mBAAmBjC,EAAMD,KAAKoC,EAAK,EAAG,IAAM,MAAQvD,KAAKqD,mBAAmBjC,EAAMD,KAAKoC,GAAM,IAAM,IAEvHA,EAAI/B,cAAgBiC,OAC3B9D,EAAOsC,GAAK,UACLsB,EAAI/B,cAAgBC,SAC3B9B,EAAOsC,GAAK,YACLsB,EAAI/B,cAAgBkC,OAC3B/D,EAAOsC,GAAK,IAAMsB,EAAM,IACjBA,EAAI/B,cAAgBmC,SAC3BhE,EAAOsC,GAAKsB,IAIxB,OAAO5D,EAAOiE,KAAK,MAGvBC,eAKAC,KAAM,SAASC,GACX,IAAIC,EAAMhE,KAAKiE,sBACf,GAAID,EACA,IAMI,OALAA,EAAIE,KAAK,MAAOH,GAAK,GAGrBC,EAAIG,KAAK,MAEFH,EAAII,aACb,MAAO5E,IAGb,MAAO,IAQXyE,oBAAqB,WAYjB,IAXA,IAAII,EAASC,GACT,WACI,OAAO,IAAIC,gBACZ,WACC,OAAO,IAAIC,cAAc,mBAC1B,WACC,OAAO,IAAIA,cAAc,mBAC1B,WACC,OAAO,IAAIA,cAAc,uBAGxBvC,EAAI,EAAGA,EAAIqC,EAAiBzD,OAAQoB,IACzC,IAII,OAHAoC,EAAUC,EAAiBrC,KAE3BjC,KAAKiE,oBAAsBK,EAAiBrC,GACrCoC,EACT,MAAO7E,MAYjBiF,aAAc,SAASV,GACnB,OAA2C,IAApCA,EAAIpD,QAAQ0B,SAASqC,WAShCC,UAAW,SAASZ,GAKhB,OAHMA,KAAO/D,KAAK6D,cACd7D,KAAK6D,YAAYE,GAAO/D,KAAK8D,KAAKC,GAAKnD,MAAM,OAE1CZ,KAAK6D,YAAYE,IAG5BlE,wBAAyB,SAASS,GAC9B,IAAK,IAAI2B,EAAI,EAAGA,EAAI3B,EAAMO,SAAUoB,EAAG,CACnC,IAEI2C,EAAQtE,EAAM2B,GAAI4C,EAFR,2BAEsBzC,KAAKwC,GAEzC,GAAIC,EAAK,CACL,IAAIC,EAJI,0CAIM1C,KAAKyC,EAAI,IACvB,GAAIC,EAAG,CACH,IAAIC,EAAOD,EAAE,GAAIE,EAASF,EAAE,GAAIG,EAASH,EAAE,IAAM,EACjD,GAAIC,GAAQ/E,KAAKyE,aAAaM,IAASC,EAAQ,CAC3C,IAAIhE,EAAehB,KAAKkF,uBAAuBH,EAAMC,EAAQC,GAC7D3E,EAAM2B,GAAK2C,EAAMjD,QAAQ,cAAeX,MAKxD,OAAOV,GAGX4E,uBAAwB,SAASnB,EAAKoB,EAAQC,GAC1C,IAAIC,EACJ,IACIA,EAAMrF,KAAKsF,iBAAiBtF,KAAK2E,UAAUZ,GAAMoB,GACnD,MAAO3F,GACL6F,EAAM,8BAAgCtB,EAAM,gBAAkBvE,EAAEyD,WAEpE,OAAOoC,GAGXC,iBAAkB,SAASC,EAAQJ,GAc/B,IATA,IAQeK,EAAuCV,EAAGW,EARrDC,EAAwB,oCAGxBC,EAAuB,gDAEvBC,EAAuB,6DAGvBC,EAAO,GAAUC,EAAWC,KAAKC,IAAIb,EAAQ,IACxClD,EAAI,EAAGA,EAAI6D,IAAY7D,EAQ5B,IALAwD,GADAD,EAAOD,EAAOJ,EAASlD,EAAI,IACTtB,QAAQ,QACR,IACd6E,EAAOA,EAAKS,OAAO,EAAGR,IAGtBD,EAAM,CAGN,GAFAK,EAAOL,EAAOK,GACdf,EAAIa,EAAqBvD,KAAKyD,KACrBf,EAAE,GACP,OAAOA,EAAE,GAGb,IADAA,EAAIY,EAAsBtD,KAAKyD,KACtBf,EAAE,GAEP,OAAOA,EAAE,GAGb,IADAA,EAAIc,EAAqBxD,KAAKyD,KACrBf,EAAE,GACP,OAAOA,EAAE,GAIrB,MAAO,QAIR3F,EAAOC,WAAaA","file":"../stack-trace.js","sourcesContent":["define([\"./debugs\"],function(debugs) {\r\n\r\n    // The module borrowed the following programï¼š \r\n    //   Domain Public by Eric Wendelin http://eriwen.com/ (2008)\r\n    //                  Luke Smith http://lucassmith.name/ (2008)\r\n    //                  Loic Dachary <loic@dachary.org> (2008)\r\n    //                  Johan Euphrosine <proppy@aminche.com> (2008)\r\n    //                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\r\n    //                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\r\n\r\n    /**\r\n     * Main function giving a function stack trace with a forced or passed in Error\r\n     *\r\n     * @cfg {Error} e The error to create a stacktrace from (optional)\r\n     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\r\n     * @return {Array} of Strings with functions, lines, files, and arguments where possible\r\n     */\r\n    function StackTrace(options) {\r\n        options = options || {guess: true};\r\n        var ex = options.e || null, guess = !!options.guess;\r\n        var p = new StackTrace.implementation(), result = p.run(ex);\r\n        return (guess) ? p.guessAnonymousFunctions(result) : result;\r\n    }\r\n\r\n    StackTrace.implementation = function() {\r\n    };\r\n\r\n    StackTrace.implementation.prototype = {\r\n        /**\r\n         * @param {Error} ex The error to create a stacktrace from (optional)\r\n         * @param {String} mode Forced mode (optional, mostly for unit tests)\r\n         */\r\n        run: function(ex, mode) {\r\n            ex = ex || this.createException();\r\n            // examine exception properties w/o debugger\r\n            //for (var prop in ex) {alert(\"Ex['\" + prop + \"']=\" + ex[prop]);}\r\n            mode = mode || this.mode(ex);\r\n            if (mode === 'other') {\r\n                return this.other(arguments.callee);\r\n            } else {\r\n                return this[mode](ex);\r\n            }\r\n        },\r\n\r\n        createException: function() {\r\n            try {\r\n                this.undef();\r\n            } catch (e) {\r\n                return e;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mode could differ for different exception, e.g.\r\n         * exceptions in Chrome may or may not have arguments or stack.\r\n         *\r\n         * @return {String} mode of operation for the exception\r\n         */\r\n        mode: function(e) {\r\n            if (e['arguments'] && e.stack) {\r\n                return 'chrome';\r\n            } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\r\n                // e.message.indexOf(\"Backtrace:\") > -1 -> opera\r\n                // !e.stacktrace -> opera\r\n                if (!e.stacktrace) {\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                // 'opera#sourceloc' in e -> opera9, opera10a\r\n                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                // e.stacktrace && !e.stack -> opera10a\r\n                if (!e.stack) {\r\n                    return 'opera10a'; // use e.stacktrace\r\n                }\r\n                // e.stacktrace && e.stack -> opera10b\r\n                if (e.stacktrace.indexOf(\"called from line\") < 0) {\r\n                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\r\n                }\r\n                // e.stacktrace && e.stack -> opera11\r\n                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\r\n            } else if (e.stack) {\r\n                return 'firefox';\r\n            }\r\n            return 'other';\r\n        },\r\n\r\n        /**\r\n         * Given a context, function name, and callback function, overwrite it so that it calls\r\n         * StackTrace() first with a callback and then runs the rest of the body.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to instrument\r\n         * @param {Function} function to call with a stack trace on invocation\r\n         */\r\n        instrumentFunction: function(context, functionName, callback) {\r\n            context = context || window;\r\n            var original = context[functionName];\r\n            context[functionName] = function instrumented() {\r\n                callback.call(this, StackTrace().slice(4));\r\n                return context[functionName]._instrumented.apply(this, arguments);\r\n            };\r\n            context[functionName]._instrumented = original;\r\n        },\r\n\r\n        /**\r\n         * Given a context and function name of a function that has been\r\n         * instrumented, revert the function to it's original (non-instrumented)\r\n         * state.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to de-instrument\r\n         */\r\n        deinstrumentFunction: function(context, functionName) {\r\n            if (context[functionName].constructor === Function &&\r\n                    context[functionName]._instrumented &&\r\n                    context[functionName]._instrumented.constructor === Function) {\r\n                context[functionName] = context[functionName]._instrumented;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Chrome's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        chrome: function(e) {\r\n            var stack = (e.stack + '\\n').replace(/^\\S[^\\(]+?[\\n$]/gm, '').\r\n              replace(/^\\s+(at eval )?at\\s+/gm, '').\r\n              replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}()@$1$2').\r\n              replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}()@$1').split('\\n');\r\n            stack.pop();\r\n            return stack;\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Firefox's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        firefox: function(e) {\r\n            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^\\(/gm, '{anonymous}(').split('\\n');\r\n        },\r\n\r\n        opera11: function(e) {\r\n            // \"Error thrown at line 42, column 12 in <anonymous function>() in file://localhost/G:/js/stacktrace.js:\\n\"\r\n            // \"Error thrown at line 42, column 12 in <anonymous function: createException>() in file://localhost/G:/js/stacktrace.js:\\n\"\r\n            // \"called from line 7, column 4 in bar(n) in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\r\n            // \"called from line 15, column 3 in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\r\n            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var location = match[4] + ':' + match[1] + ':' + match[2];\r\n                    var fnName = match[3] || \"global code\";\r\n                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\r\n                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        opera10b: function(e) {\r\n            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\r\n            // \"StackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\r\n            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\r\n            var lineRE = /^(.*)@(.+):(\\d+)$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i++) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[1]? (match[1] + '()') : \"global code\";\r\n                    result.push(fnName + '@' + match[2] + ':' + match[3]);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        opera10a: function(e) {\r\n            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[3] || ANON;\r\n                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Opera 7.x-9.2x only!\r\n        opera9: function(e) {\r\n            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\r\n            var lines = e.message.split('\\n'), result = [];\r\n\r\n            for (var i = 2, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Safari, IE, and others\r\n        other: function(curr) {\r\n            var ANON = '{anonymous}', fnRE = /function\\s*([\\w\\-$]+)?\\s*\\(/i, stack = [], fn, args, maxStackSize = 10;\r\n            while (curr && curr['arguments'] && stack.length < maxStackSize) {\r\n                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\r\n                args = Array.prototype.slice.call(curr['arguments'] || []);\r\n                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\r\n                curr = curr.caller;\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        /**\r\n         * Given arguments array as a String, subsituting type names for non-string types.\r\n         *\r\n         * @param {Arguments} object\r\n         * @return {Array} of Strings with stringified arguments\r\n         */\r\n        stringifyArguments: function(args) {\r\n            var result = [];\r\n            var slice = Array.prototype.slice;\r\n            for (var i = 0; i < args.length; ++i) {\r\n                var arg = args[i];\r\n                if (arg === undefined) {\r\n                    result[i] = 'undefined';\r\n                } else if (arg === null) {\r\n                    result[i] = 'null';\r\n                } else if (arg.constructor) {\r\n                    if (arg.constructor === Array) {\r\n                        if (arg.length < 3) {\r\n                            result[i] = '[' + this.stringifyArguments(arg) + ']';\r\n                        } else {\r\n                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\r\n                        }\r\n                    } else if (arg.constructor === Object) {\r\n                        result[i] = '#object';\r\n                    } else if (arg.constructor === Function) {\r\n                        result[i] = '#function';\r\n                    } else if (arg.constructor === String) {\r\n                        result[i] = '\"' + arg + '\"';\r\n                    } else if (arg.constructor === Number) {\r\n                        result[i] = arg;\r\n                    }\r\n                }\r\n            }\r\n            return result.join(',');\r\n        },\r\n\r\n        sourceCache: {},\r\n\r\n        /**\r\n         * @return the text from a given URL\r\n         */\r\n        ajax: function(url) {\r\n            var req = this.createXMLHTTPObject();\r\n            if (req) {\r\n                try {\r\n                    req.open('GET', url, false);\r\n                    //req.overrideMimeType('text/plain');\r\n                    //req.overrideMimeType('text/javascript');\r\n                    req.send(null);\r\n                    //return req.status == 200 ? req.responseText : '';\r\n                    return req.responseText;\r\n                } catch (e) {\r\n                }\r\n            }\r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * Try XHR methods in order and store XHR factory.\r\n         *\r\n         * @return <Function> XHR function or equivalent\r\n         */\r\n        createXMLHTTPObject: function() {\r\n            var xmlhttp, XMLHttpFactories = [\r\n                function() {\r\n                    return new XMLHttpRequest();\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml2.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml3.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Microsoft.XMLHTTP');\r\n                }\r\n            ];\r\n            for (var i = 0; i < XMLHttpFactories.length; i++) {\r\n                try {\r\n                    xmlhttp = XMLHttpFactories[i]();\r\n                    // Use memoization to cache the factory\r\n                    this.createXMLHTTPObject = XMLHttpFactories[i];\r\n                    return xmlhttp;\r\n                } catch (e) {\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given a URL, check if it is in the same domain (so we can get the source\r\n         * via Ajax).\r\n         *\r\n         * @param url <String> source url\r\n         * @return False if we need a cross-domain request\r\n         */\r\n        isSameDomain: function(url) {\r\n            return url.indexOf(location.hostname) !== -1;\r\n        },\r\n\r\n        /**\r\n         * Get source code from given URL if in the same domain.\r\n         *\r\n         * @param url <String> JS source URL\r\n         * @return <Array> Array of source code lines\r\n         */\r\n        getSource: function(url) {\r\n            // TODO reuse source from script tags?\r\n            if (!(url in this.sourceCache)) {\r\n                this.sourceCache[url] = this.ajax(url).split('\\n');\r\n            }\r\n            return this.sourceCache[url];\r\n        },\r\n\r\n        guessAnonymousFunctions: function(stack) {\r\n            for (var i = 0; i < stack.length; ++i) {\r\n                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\r\n                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\r\n                    frame = stack[i], ref = reStack.exec(frame);\r\n\r\n                if (ref) {\r\n                    var m = reRef.exec(ref[1]);\r\n                    if (m) { // If falsey, we did not get any file/line information\r\n                        var file = m[1], lineno = m[2], charno = m[3] || 0;\r\n                        if (file && this.isSameDomain(file) && lineno) {\r\n                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\r\n                            stack[i] = frame.replace('{anonymous}', functionName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        guessAnonymousFunction: function(url, lineNo, charNo) {\r\n            var ret;\r\n            try {\r\n                ret = this.findFunctionName(this.getSource(url), lineNo);\r\n            } catch (e) {\r\n                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\r\n            }\r\n            return ret;\r\n        },\r\n\r\n        findFunctionName: function(source, lineNo) {\r\n            // FIXME findFunctionName fails for compressed source\r\n            // (more than one function on the same line)\r\n            // TODO use captured args\r\n            // function {name}({args}) m[1]=name m[2]=args\r\n            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\r\n            // {name} = function ({args}) TODO args capture\r\n            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\r\n            var reFunctionExpression = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function\\b/;\r\n            // {name} = eval()\r\n            var reFunctionEvaluation = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\r\n            // Walk backwards in the source lines until we find\r\n            // the line which matches one of the patterns above\r\n            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\r\n            for (var i = 0; i < maxLines; ++i) {\r\n                // lineNo is 1-based, source[] is 0-based\r\n                line = source[lineNo - i - 1];\r\n                commentPos = line.indexOf('//');\r\n                if (commentPos >= 0) {\r\n                    line = line.substr(0, commentPos);\r\n                }\r\n                // TODO check other types of comments? Commented code may lead to false positive\r\n                if (line) {\r\n                    code = line + code;\r\n                    m = reFunctionExpression.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionDeclaration.exec(code);\r\n                    if (m && m[1]) {\r\n                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionEvaluation.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                }\r\n            }\r\n            return '(?)';\r\n        }\r\n    };\r\n\r\n    return debugs.StackTrace = StackTrace;\r\n});\r\n"]}