{"version":3,"sources":["skylark-langx-debugs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-langx-debugs.js","sourcesContent":["define('skylark-langx-debugs/debugs',[\r\n    \"skylark-langx-ns\"\r\n], function(skylark) {\r\n\treturn skylark.attach(\"langx.debugs\");\r\n});\ndefine('skylark-langx-debugs/stack-trace',[\"./debugs\"],function(debugs) {\r\n\r\n    // The module borrowed the following programï¼š \r\n    //   Domain Public by Eric Wendelin http://eriwen.com/ (2008)\r\n    //                  Luke Smith http://lucassmith.name/ (2008)\r\n    //                  Loic Dachary <loic@dachary.org> (2008)\r\n    //                  Johan Euphrosine <proppy@aminche.com> (2008)\r\n    //                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\r\n    //                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\r\n\r\n    /**\r\n     * Main function giving a function stack trace with a forced or passed in Error\r\n     *\r\n     * @cfg {Error} e The error to create a stacktrace from (optional)\r\n     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\r\n     * @return {Array} of Strings with functions, lines, files, and arguments where possible\r\n     */\r\n    function StackTrace(options) {\r\n        options = options || {guess: true};\r\n        var ex = options.e || null, guess = !!options.guess;\r\n        var p = new StackTrace.implementation(), result = p.run(ex);\r\n        return (guess) ? p.guessAnonymousFunctions(result) : result;\r\n    }\r\n\r\n    StackTrace.implementation = function() {\r\n    };\r\n\r\n    StackTrace.implementation.prototype = {\r\n        /**\r\n         * @param {Error} ex The error to create a stacktrace from (optional)\r\n         * @param {String} mode Forced mode (optional, mostly for unit tests)\r\n         */\r\n        run: function(ex, mode) {\r\n            ex = ex || this.createException();\r\n            // examine exception properties w/o debugger\r\n            //for (var prop in ex) {alert(\"Ex['\" + prop + \"']=\" + ex[prop]);}\r\n            mode = mode || this.mode(ex);\r\n            if (mode === 'other') {\r\n                return this.other(arguments.callee);\r\n            } else {\r\n                return this[mode](ex);\r\n            }\r\n        },\r\n\r\n        createException: function() {\r\n            try {\r\n                this.undef();\r\n            } catch (e) {\r\n                return e;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mode could differ for different exception, e.g.\r\n         * exceptions in Chrome may or may not have arguments or stack.\r\n         *\r\n         * @return {String} mode of operation for the exception\r\n         */\r\n        mode: function(e) {\r\n            if (e['arguments'] && e.stack) {\r\n                return 'chrome';\r\n            } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\r\n                // e.message.indexOf(\"Backtrace:\") > -1 -> opera\r\n                // !e.stacktrace -> opera\r\n                if (!e.stacktrace) {\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                // 'opera#sourceloc' in e -> opera9, opera10a\r\n                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                // e.stacktrace && !e.stack -> opera10a\r\n                if (!e.stack) {\r\n                    return 'opera10a'; // use e.stacktrace\r\n                }\r\n                // e.stacktrace && e.stack -> opera10b\r\n                if (e.stacktrace.indexOf(\"called from line\") < 0) {\r\n                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\r\n                }\r\n                // e.stacktrace && e.stack -> opera11\r\n                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\r\n            } else if (e.stack) {\r\n                return 'firefox';\r\n            }\r\n            return 'other';\r\n        },\r\n\r\n        /**\r\n         * Given a context, function name, and callback function, overwrite it so that it calls\r\n         * StackTrace() first with a callback and then runs the rest of the body.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to instrument\r\n         * @param {Function} function to call with a stack trace on invocation\r\n         */\r\n        instrumentFunction: function(context, functionName, callback) {\r\n            context = context || window;\r\n            var original = context[functionName];\r\n            context[functionName] = function instrumented() {\r\n                callback.call(this, StackTrace().slice(4));\r\n                return context[functionName]._instrumented.apply(this, arguments);\r\n            };\r\n            context[functionName]._instrumented = original;\r\n        },\r\n\r\n        /**\r\n         * Given a context and function name of a function that has been\r\n         * instrumented, revert the function to it's original (non-instrumented)\r\n         * state.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to de-instrument\r\n         */\r\n        deinstrumentFunction: function(context, functionName) {\r\n            if (context[functionName].constructor === Function &&\r\n                    context[functionName]._instrumented &&\r\n                    context[functionName]._instrumented.constructor === Function) {\r\n                context[functionName] = context[functionName]._instrumented;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Chrome's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        chrome: function(e) {\r\n            var stack = (e.stack + '\\n').replace(/^\\S[^\\(]+?[\\n$]/gm, '').\r\n              replace(/^\\s+(at eval )?at\\s+/gm, '').\r\n              replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}()@$1$2').\r\n              replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}()@$1').split('\\n');\r\n            stack.pop();\r\n            return stack;\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Firefox's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        firefox: function(e) {\r\n            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^\\(/gm, '{anonymous}(').split('\\n');\r\n        },\r\n\r\n        opera11: function(e) {\r\n            // \"Error thrown at line 42, column 12 in <anonymous function>() in file://localhost/G:/js/stacktrace.js:\\n\"\r\n            // \"Error thrown at line 42, column 12 in <anonymous function: createException>() in file://localhost/G:/js/stacktrace.js:\\n\"\r\n            // \"called from line 7, column 4 in bar(n) in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\r\n            // \"called from line 15, column 3 in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\r\n            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var location = match[4] + ':' + match[1] + ':' + match[2];\r\n                    var fnName = match[3] || \"global code\";\r\n                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\r\n                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        opera10b: function(e) {\r\n            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\r\n            // \"StackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\r\n            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\r\n            var lineRE = /^(.*)@(.+):(\\d+)$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i++) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[1]? (match[1] + '()') : \"global code\";\r\n                    result.push(fnName + '@' + match[2] + ':' + match[3]);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        opera10a: function(e) {\r\n            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[3] || ANON;\r\n                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Opera 7.x-9.2x only!\r\n        opera9: function(e) {\r\n            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\r\n            var lines = e.message.split('\\n'), result = [];\r\n\r\n            for (var i = 2, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Safari, IE, and others\r\n        other: function(curr) {\r\n            var ANON = '{anonymous}', fnRE = /function\\s*([\\w\\-$]+)?\\s*\\(/i, stack = [], fn, args, maxStackSize = 10;\r\n            while (curr && curr['arguments'] && stack.length < maxStackSize) {\r\n                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\r\n                args = Array.prototype.slice.call(curr['arguments'] || []);\r\n                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\r\n                curr = curr.caller;\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        /**\r\n         * Given arguments array as a String, subsituting type names for non-string types.\r\n         *\r\n         * @param {Arguments} object\r\n         * @return {Array} of Strings with stringified arguments\r\n         */\r\n        stringifyArguments: function(args) {\r\n            var result = [];\r\n            var slice = Array.prototype.slice;\r\n            for (var i = 0; i < args.length; ++i) {\r\n                var arg = args[i];\r\n                if (arg === undefined) {\r\n                    result[i] = 'undefined';\r\n                } else if (arg === null) {\r\n                    result[i] = 'null';\r\n                } else if (arg.constructor) {\r\n                    if (arg.constructor === Array) {\r\n                        if (arg.length < 3) {\r\n                            result[i] = '[' + this.stringifyArguments(arg) + ']';\r\n                        } else {\r\n                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\r\n                        }\r\n                    } else if (arg.constructor === Object) {\r\n                        result[i] = '#object';\r\n                    } else if (arg.constructor === Function) {\r\n                        result[i] = '#function';\r\n                    } else if (arg.constructor === String) {\r\n                        result[i] = '\"' + arg + '\"';\r\n                    } else if (arg.constructor === Number) {\r\n                        result[i] = arg;\r\n                    }\r\n                }\r\n            }\r\n            return result.join(',');\r\n        },\r\n\r\n        sourceCache: {},\r\n\r\n        /**\r\n         * @return the text from a given URL\r\n         */\r\n        ajax: function(url) {\r\n            var req = this.createXMLHTTPObject();\r\n            if (req) {\r\n                try {\r\n                    req.open('GET', url, false);\r\n                    //req.overrideMimeType('text/plain');\r\n                    //req.overrideMimeType('text/javascript');\r\n                    req.send(null);\r\n                    //return req.status == 200 ? req.responseText : '';\r\n                    return req.responseText;\r\n                } catch (e) {\r\n                }\r\n            }\r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * Try XHR methods in order and store XHR factory.\r\n         *\r\n         * @return <Function> XHR function or equivalent\r\n         */\r\n        createXMLHTTPObject: function() {\r\n            var xmlhttp, XMLHttpFactories = [\r\n                function() {\r\n                    return new XMLHttpRequest();\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml2.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml3.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Microsoft.XMLHTTP');\r\n                }\r\n            ];\r\n            for (var i = 0; i < XMLHttpFactories.length; i++) {\r\n                try {\r\n                    xmlhttp = XMLHttpFactories[i]();\r\n                    // Use memoization to cache the factory\r\n                    this.createXMLHTTPObject = XMLHttpFactories[i];\r\n                    return xmlhttp;\r\n                } catch (e) {\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given a URL, check if it is in the same domain (so we can get the source\r\n         * via Ajax).\r\n         *\r\n         * @param url <String> source url\r\n         * @return False if we need a cross-domain request\r\n         */\r\n        isSameDomain: function(url) {\r\n            return url.indexOf(location.hostname) !== -1;\r\n        },\r\n\r\n        /**\r\n         * Get source code from given URL if in the same domain.\r\n         *\r\n         * @param url <String> JS source URL\r\n         * @return <Array> Array of source code lines\r\n         */\r\n        getSource: function(url) {\r\n            // TODO reuse source from script tags?\r\n            if (!(url in this.sourceCache)) {\r\n                this.sourceCache[url] = this.ajax(url).split('\\n');\r\n            }\r\n            return this.sourceCache[url];\r\n        },\r\n\r\n        guessAnonymousFunctions: function(stack) {\r\n            for (var i = 0; i < stack.length; ++i) {\r\n                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\r\n                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\r\n                    frame = stack[i], ref = reStack.exec(frame);\r\n\r\n                if (ref) {\r\n                    var m = reRef.exec(ref[1]);\r\n                    if (m) { // If falsey, we did not get any file/line information\r\n                        var file = m[1], lineno = m[2], charno = m[3] || 0;\r\n                        if (file && this.isSameDomain(file) && lineno) {\r\n                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\r\n                            stack[i] = frame.replace('{anonymous}', functionName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        guessAnonymousFunction: function(url, lineNo, charNo) {\r\n            var ret;\r\n            try {\r\n                ret = this.findFunctionName(this.getSource(url), lineNo);\r\n            } catch (e) {\r\n                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\r\n            }\r\n            return ret;\r\n        },\r\n\r\n        findFunctionName: function(source, lineNo) {\r\n            // FIXME findFunctionName fails for compressed source\r\n            // (more than one function on the same line)\r\n            // TODO use captured args\r\n            // function {name}({args}) m[1]=name m[2]=args\r\n            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\r\n            // {name} = function ({args}) TODO args capture\r\n            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\r\n            var reFunctionExpression = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function\\b/;\r\n            // {name} = eval()\r\n            var reFunctionEvaluation = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\r\n            // Walk backwards in the source lines until we find\r\n            // the line which matches one of the patterns above\r\n            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\r\n            for (var i = 0; i < maxLines; ++i) {\r\n                // lineNo is 1-based, source[] is 0-based\r\n                line = source[lineNo - i - 1];\r\n                commentPos = line.indexOf('//');\r\n                if (commentPos >= 0) {\r\n                    line = line.substr(0, commentPos);\r\n                }\r\n                // TODO check other types of comments? Commented code may lead to false positive\r\n                if (line) {\r\n                    code = line + code;\r\n                    m = reFunctionExpression.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionDeclaration.exec(code);\r\n                    if (m && m[1]) {\r\n                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionEvaluation.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                }\r\n            }\r\n            return '(?)';\r\n        }\r\n    };\r\n\r\n    return debugs.StackTrace = StackTrace;\r\n});\r\n\ndefine('skylark-langx-debugs/main',[\r\n    \"./debugs\",\r\n    \"./stack-trace\"\r\n], function(debugs) {\r\n    return debugs;\r\n});\r\n\ndefine('skylark-langx-debugs', ['skylark-langx-debugs/main'], function (main) { return main; });\n\n"]}